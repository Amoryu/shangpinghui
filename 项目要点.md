node_modules：项目依赖
public:静态资源，webpack 打包时原封不动放到 dist 文件夹中
src:项目源代码文件夹
asset:静态资源（多个组件共用的静态资源，webpack 打包时会把静态资源当作模块，打包到 js 文件里）
components:非路由组件，常用的全局组件
App.vue:项目唯一的根组件
.gitignore:Git 忽略文件

babel.config.js:把 ES6 语法翻译成 ES5 语法，保证兼容性

package.json:项目的身份证，记录项目信息，依赖，如何运行等

package.lock.json:缓存性文件

README.md：说明性文件

vue.config.js 中配置 lintOnSave:false 关闭 ESlint 语法检查

---

1.项目路由分析
key:url 路径
value:相应的路由

项目是上中下结构
路由组件
Home 首页路由组件，Search 路由组件，Login 登录路由，register 注册路由
非路由组件
Header【首页，搜索页】,Footer【首页，搜索页】

项目当中路由组件都要在 router/index.js 中注册
$route:一般获取路由信息（路劲，query,params）
$router:编程式导航，路由跳转【push，replace】

注册完路由，不管是路由还是非路由组件，都有$route，$router 属性
路径下的 index.js 或者 index.vue 可不用写

##2.路由的跳转：
声明式导航：router-link
编程式导航：push/replace
声明式导航能做的，编程式导航都能做，而且能做一些其他业务逻辑

##3.Footer 显示与隐藏
从性能角度，v-show 更好一些,
Home,Search 显示
Login，Register 隐藏
解决方案： 1.通过路由路径判断显示或隐藏 2.路由元信息,meta:{show:true}

##4.路由传参
query:不属于路径中的一部分,（?后面接的）
params 属于路径的一部分,接在路径后面你
==传递 params 参数前，一定要在路由规则中配置占位符==

##5.编程式路由跳转至当前路由时,多次执行会抛出 NavigationDuplicated 警告错误
声明式导航,不会出现这个问题,vuerouter 底层已经处理好了
编程式导航,则会报错 push 方法返回一个 promise 对象,只需给 push 添加成功和失败的回调,就可以解决(治标不治本)

##6Home 组件
拆分静态组件 1.三级联动组件,(注册为全局组件 2.要点:html 结构,css 样式,缺一不可(尤其注意导入图片资源,以及修改 html 结构和 css 样式中的图片路径)

##7POSTMAN 接口测试
服务器返回 200,代表服务器返回数据成功
###axios 二次封装
请求拦截器:可以在发送请求之前处理一些业务
响应拦截器,当服务器返回数据 zhi

1.在项目 src 下创建 api 文件夹,创建 request.js

2.接口统一管理
项目很小.完全可以在组件的生命周期函数中发请求
项目很大,请求统一管理 axios.get('xxx')
2.1 api 下创建 index.js

2.2 **跨域问题**
跨域,域名不同,端口不同,协议不同
解决方案:CORS,JSONP,代理
前端项目本地服务器 http://localhost:8080/#/home
要获取的后台服务器 // http://gmall-h5-api.atguigu.cn/api/product/getBaseCategoryList
==配置代理跨域==
vue.config.js 中配置(配置完需要重启 vue-cli)
devServer: {
proxy: {
'/api': {
target: 'http://gmall-h5-api.atguigu.cn',
pathRewrite: { '^/api': '' }
}
}
}

8.nprogress 进度条
start:进度条开始
done:进度条结束
修改进度条颜色,nprogress.css 中的.bar 颜色

9.**vuex**
状态管理库,项目中共用的数据
项目很小,完全不需要 vuex
项目很大,组件多,数据多,数据维护困难,用 vuex

9.1vuex 实现模块式开发
项目过大,数据过多,类别过多,将 store 拆分成多个模块

10.完成 TypeNav 三级联动数据展示业务
10.1 一级分类动态背景颜色
第一种解决方案:采用 css 样式完成
第二种解决方案:js 完成

11.完成二三级分类显示与隐藏

**卡顿现象-----节流防抖**

12.三级联动组件的路由跳转与传递参数
从 home 跳转到 search,一级会把用户选中的产品(名字,ID)传递给

声明式导航,可以实现路由跳转与传递,但会出现卡断现象
router-link:当服务器的数据返回之后,v-for 就会循环出大量 router-link 组件,创建组件实例的时候,一瞬间创建 1000+,很耗内存,出现卡顿(所以不建议用声明式导航)

**复习:** 1.获取服务器存在跨域问题,用代理或 CORS 解决 2.函数防抖和节流 3.三级列表,声明式导航存在性能问题,数据多,要渲染的组件多,耗内存,会造成卡顿,
3.1 编程式导航+事件委派+自定义属性解决 3 的问题
解决事件委派确定点击的是 a 标签,使用自定义属性确定 4.区分一二三级目录,使用自定义属性确定

13.Search 模块
13.1 Search 模块中的 TypeNav 三级分类列表显示与隐藏
过渡动画:前提是组件必须有 v-if 或 v-show 属性

**性能优化--------Home 和 Search 跳转时,都要发送数据请求**
因为 TypeNav 组件发送请求定义在 mounted 钩子里,每次 TypeNav 组件挂载完成,都会发送请求
**优化方案**:数据请求放到根组件 App 的 mounted 钩子中,只执行一次数据请求,(不能放到 main.js 中,因为 main.js 中的 this 不指向组件实例,只有组件实例上才有$store 属性)

14.合并参数
既要 query 参数,也要 prams 参数,

15.开发 Home 首页中的 ListContainer 组件与 Floor 组件
mock.js 数据(模拟):生成随机数据
mock 请求不能发出去,会被浏览器拦截,只作为模拟测试使用,不和服务器打交道
mockjs 使用步骤
1).创建 mock 文件夹
2).准备 JSON 数据(mock 文件夹中创建对应 json 文件)
3).把 mock 数据需要的图片放置到 public 文件夹中,打包时,会将相应的资源原封不动打包到 dist 文件夹中
4).创建 mockServer.js 通过 mockjs 插件模拟数据
5). mockServer.js 文件在入口文件 main.js 中引入，（至少需要执行一次，才能模拟数据）

15.1 ListContainer 开发重点
轮播图
安装 swiper@5

**复习** 1)完成三级列表路由跳转并传参（合并参数
2）完成 Search 模块的 TypeNav 过渡动画 3)对于 TypeNav 请求进行优化（三级列表 a 标签的渲染，自定义属性确定点击的内容）
4）swiper 轮播图插件
使用步骤
第一步：引入相应依赖包
第二步：页面的结构务必要有【尤其注意需要发送请求来渲染页面结构的情况】
第三步：初始化 swiper 实例，给轮播图添加动态效果
5）mock 数据，通过 mockjs 模块实现

16.**最完美的轮播图解决方案**
watch + nextTick:数据监听，监听已有数据的变化

17.开发 Floor 组件
仓库中的 state 的数据，不能乱写，数据格式取决于服务器返回的数据格式

17.1 v-for 也可以在自定义组件标签中使用
**组件通信的方式有哪些**
1）props:父子组件通信
2）自定义事件按：子给父通信
3）全局事件总线$bus 全能
4）pubsub 订阅事件，任意组件通信
5）插槽 6) vuex

18.拆分首页的轮播图为共用的全局组件
Carousel.vue

19.Search 模块开发 1)写静态 2)拆结构弄组件 3)发请求弄数据
4)vuex(actions->mutations->state) 5)组件获取仓库数据，动态展示数据

**复习**
1）Search 模块需要的服务器数据，已经请求到，存储到 vuex 仓库中了，已经通过 getters 进行了初始化

2）动态开发面包屑的分类名 category1/2/3Id
编程式导航路由跳转【自身跳转到自身】

3）动态开打面包屑的分类名 categoryName
面包屑中的关键字清除后，通知兄弟组件 header 清除关键字

4)动态开发售卖属性的面包屑 attrsList
**数组去重**
if (this.searchParams.props.indexOf(prop) === -1)

5)清除面包屑
splice(index,x)删除索引值为 index 的元素

4)**排序操作**
1>.综合 2.价格
2>asc:升序,desc:降序

排序函数，
获取初始的 order
通过 order.split(':')获取 flag 和 sort
flag:区分综合和价格
sort: 升序还是降序
定义 newOrder 保存新的 flag 和 sort
把 newOrder 重新写入 searchParams 参数，并发送新的请求

5)**分页器** 1)总共有多少条数据 total 2)每页展示多少条数据 Pagesize 3)总共有多少页((数据总数/每页展示数据量)向上取整) PageNo 4)展示当前页数据
5）连续的页码数 continue（5 或 7）

向上取整：Math.ceil(this.total / this.pageSize)
连续页码起始页，结束页

> > 异常情况
> > 起始页码小于最小页码，结束页码大于总页码
> > 总结：防止出现上下越界的情况

分页器动态展示【上中下部分】
v-for 可以遍历数字 number

20.开发产品的详情页
1）静态组件
2）发起请求
3）vuex
4）动态展示组件

21)详情页的**滚动行为 scrollBehavior**

22)加入购物车按钮
1）路由跳转前发请求
2）成功跳转并传参
浏览器存储，HTML5 新增的，本地存储和会话存储

3）失败提示用户失败信息

> 2addCartSuccess
> 1）查看详情
> 本地存储购物车信息，一般存储字符串
> (会话存储，会话结束时（页面关闭）数据消失)

> 23**购物车组件**
>
> > 1 引入静态组件，注册路由规则 > >2.发请求，获取数据，vuex 三连环 3.发请求时，服务器获取不到购物车里面的数据，因为服务器无法认证你的身份

**uuid 身份认证**

3.动态展示购物车

修改商品数量-------节流

4.删除选中的全部商品的操作

5.修改商品状态

6.全选操作

**登陆预注册静态组件**

> 注册业务
> 获取验证码
> 注册用户

> 登录业务 1.注册---------通过数据库存储用户信息 2.登录---------登陆成功的时候，后台为了区分你这个用户是谁，服务器下发 token【唯一标识符】
> 3。服务器一般只下发 token  
> token 令牌

> \*_注意：vuex 仓库存储数据不是持久的，刷新页面数据会丢失_：

> \*_存在问题： 多个组件要获取用户信息，需要各自在 mounted（）中获取; 用户已经登陆，不能再（通过 url）跳转到登录页面_

**导航(路由)守卫**
1).用户已经登陆，不能再（通过 url）跳转到登录页面
2).用户未登录，不能跳转到购物车页面

> 全局守卫（常用）

> 独享守卫

> 组件内守卫

**交易组件**

**提交订单业务**
支付组件
静态组件，路由规则，

不使用 vuex，发请求，获取数据保存到组件中

> > 不能在生命周期函数中使用 asunc/await
> > 配置文件发生变化，要重启脚手架

**支付业务**
生成支付二维码
qrcode 插件 npm i qrcode

**个人中心**
路由

\*_面试题:封装的组件：分页器，日历，轮播图_

> 订单列表
> 不变的结构在 v-for 循环中，也会重复渲染，所以用 v-if 取索引第一个的结构

> > 路由守卫
> > 全局前置守卫

> > \*_路由独享守卫_
> > 从购物车才能去交易页面，交易页面才能到支付页面，支付页面才能到支付成功页面
> >
> > > > 交易页面，支付成功页面
> > > > next(false):从哪来，就停在那

**表单验证**
vee-validate 插件
登录和注册

**>>路由懒加载**
把不同路由对应的组件分割成不同的代码块，路由被访问时才加载对应的组件

const foo=()=>import "@/pages/Home/index.vue"

component:foo

**打包上线**
map 文件：可以像为加密的代码一样，准确输出哪一行那一列出错
可以在项目配置中去掉 map 文件
vue.config.js 中配置 productionSourceMap:false
